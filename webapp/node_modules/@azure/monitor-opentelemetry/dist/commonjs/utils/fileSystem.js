"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getShallowFileSize = exports.getShallowDirectorySizeSync = exports.getShallowDirectorySize = exports.confirmDirExists = exports.unlinkAsync = exports.readdirAsync = exports.readFileAsync = exports.writeFileAsync = exports.appendFileAsync = exports.accessAsync = exports.mkdirAsync = exports.lstatAsync = exports.statAsync = void 0;
const tslib_1 = require("tslib");
const node_fs_1 = tslib_1.__importDefault(require("node:fs"));
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const node_util_1 = require("node:util");
exports.statAsync = (0, node_util_1.promisify)(node_fs_1.default.stat);
exports.lstatAsync = (0, node_util_1.promisify)(node_fs_1.default.lstat);
exports.mkdirAsync = (0, node_util_1.promisify)(node_fs_1.default.mkdir);
exports.accessAsync = (0, node_util_1.promisify)(node_fs_1.default.access);
exports.appendFileAsync = (0, node_util_1.promisify)(node_fs_1.default.appendFile);
exports.writeFileAsync = (0, node_util_1.promisify)(node_fs_1.default.writeFile);
exports.readFileAsync = (0, node_util_1.promisify)(node_fs_1.default.readFile);
exports.readdirAsync = (0, node_util_1.promisify)(node_fs_1.default.readdir);
exports.unlinkAsync = (0, node_util_1.promisify)(node_fs_1.default.unlink);
/**
 * Validate directory exists.
 */
const confirmDirExists = async (directory) => {
    try {
        const stats = await (0, exports.lstatAsync)(directory);
        if (!stats.isDirectory()) {
            throw new Error("Path existed but was not a directory");
        }
    }
    catch (err) {
        if (err && err.code === "ENOENT") {
            try {
                await (0, exports.mkdirAsync)(directory);
            }
            catch (mkdirErr) {
                if (mkdirErr && mkdirErr.code !== "EEXIST") {
                    // Handle race condition by ignoring EEXIST
                    throw mkdirErr;
                }
            }
        }
    }
};
exports.confirmDirExists = confirmDirExists;
/**
 * Computes the size (in bytes) of all files in a directory at the root level. Asynchronously.
 */
const getShallowDirectorySize = async (directory) => {
    // Get the directory listing
    const files = await (0, exports.readdirAsync)(directory);
    let totalSize = 0;
    // Query all file sizes
    for (const file of files) {
        const fileStats = await (0, exports.statAsync)(node_path_1.default.join(directory, file));
        if (fileStats.isFile()) {
            totalSize += fileStats.size;
        }
    }
    return totalSize;
};
exports.getShallowDirectorySize = getShallowDirectorySize;
/**
 * Computes the size (in bytes) of all files in a directory at the root level. Synchronously.
 */
const getShallowDirectorySizeSync = (directory) => {
    const files = node_fs_1.default.readdirSync(directory);
    let totalSize = 0;
    for (let i = 0; i < files.length; i++) {
        totalSize += node_fs_1.default.statSync(node_path_1.default.join(directory, files[i])).size;
    }
    return totalSize;
};
exports.getShallowDirectorySizeSync = getShallowDirectorySizeSync;
/**
 * Computes the size (in bytes) of a file asynchronously.
 */
const getShallowFileSize = async (filePath) => {
    const fileStats = await (0, exports.statAsync)(filePath);
    if (fileStats.isFile()) {
        return fileStats.size;
    }
    return null;
};
exports.getShallowFileSize = getShallowFileSize;
//# sourceMappingURL=fileSystem.js.map