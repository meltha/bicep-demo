"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TraceHandler = void 0;
const opentelemetry_instrumentation_azure_sdk_1 = require("@azure/opentelemetry-instrumentation-azure-sdk");
const monitor_opentelemetry_exporter_1 = require("@azure/monitor-opentelemetry-exporter");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const instrumentation_http_1 = require("@opentelemetry/instrumentation-http");
const instrumentation_mongodb_1 = require("@opentelemetry/instrumentation-mongodb");
const instrumentation_mysql_1 = require("@opentelemetry/instrumentation-mysql");
const instrumentation_pg_1 = require("@opentelemetry/instrumentation-pg");
const instrumentation_redis_1 = require("@opentelemetry/instrumentation-redis");
const instrumentation_redis_4_1 = require("@opentelemetry/instrumentation-redis-4");
const common_js_1 = require("../utils/common.js");
const spanProcessor_js_1 = require("./spanProcessor.js");
const azureFnHook_js_1 = require("./azureFnHook.js");
const sampler_js_1 = require("./sampler.js");
/**
 * Azure Monitor OpenTelemetry Trace Handler
 */
class TraceHandler {
    _batchSpanProcessor;
    _azureSpanProcessor;
    _azureExporter;
    _instrumentations;
    _config;
    _metricHandler;
    _azureFunctionsHook;
    _sampler;
    /**
     * Initializes a new instance of the TraceHandler class.
     * @param _config - Configuration.
     * @param _metricHandler - MetricHandler.
     */
    constructor(config, metricHandler) {
        this._config = config;
        this._metricHandler = metricHandler;
        this._instrumentations = [];
        // Check sampler precedence
        if (this._config.tracesPerSecond && this._config.tracesPerSecond >= 0) {
            // If tracesPerSecond is set, use RateLimitedSampler
            this._sampler = new monitor_opentelemetry_exporter_1.RateLimitedSampler(this._config.tracesPerSecond);
        }
        else {
            // Otherwise, use PercentageSampler with samplingRatio
            this._sampler = new sampler_js_1.ApplicationInsightsSampler(this._config.samplingRatio);
        }
        this._azureExporter = new monitor_opentelemetry_exporter_1.AzureMonitorTraceExporter(this._config.azureMonitorExporterOptions);
        const bufferConfig = {
            maxExportBatchSize: 512,
            scheduledDelayMillis: 5000,
            exportTimeoutMillis: 30000,
            maxQueueSize: 2048,
        };
        this._batchSpanProcessor = new sdk_trace_base_1.BatchSpanProcessor(this._azureExporter, bufferConfig);
        this._azureSpanProcessor = new spanProcessor_js_1.AzureMonitorSpanProcessor(this._metricHandler);
        this._azureFunctionsHook = new azureFnHook_js_1.AzureFunctionsHook();
        this._initializeInstrumentations();
    }
    getSampler() {
        return this._sampler;
    }
    getBatchSpanProcessor() {
        return this._batchSpanProcessor;
    }
    getAzureMonitorSpanProcessor() {
        return this._azureSpanProcessor;
    }
    getInstrumentations() {
        return this._instrumentations;
    }
    /**
     * Shutdown handler
     */
    // eslint-disable-next-line @typescript-eslint/require-await
    async shutdown() {
        this._azureFunctionsHook.shutdown();
    }
    /**
     * Start auto collection of telemetry
     */
    _initializeInstrumentations() {
        if (this._config.instrumentationOptions.http?.enabled) {
            const httpinstrumentationOptions = this._config.instrumentationOptions
                .http;
            const providedIgnoreOutgoingRequestHook = httpinstrumentationOptions.ignoreOutgoingRequestHook;
            const mergedIgnoreOutgoingRequestHook = (request) => {
                const result = (0, common_js_1.ignoreOutgoingRequestHook)(request);
                if (!result) {
                    // Not internal call
                    if (providedIgnoreOutgoingRequestHook) {
                        // Provided hook in config
                        return providedIgnoreOutgoingRequestHook(request);
                    }
                }
                return result;
            };
            httpinstrumentationOptions.ignoreOutgoingRequestHook = mergedIgnoreOutgoingRequestHook;
            this._instrumentations.push(new instrumentation_http_1.HttpInstrumentation(this._config.instrumentationOptions.http));
        }
        if (this._config.instrumentationOptions.azureSdk?.enabled) {
            this._instrumentations.push((0, opentelemetry_instrumentation_azure_sdk_1.createAzureSdkInstrumentation)(this._config.instrumentationOptions.azureSdk));
        }
        if (this._config.instrumentationOptions.mongoDb?.enabled) {
            this._instrumentations.push(new instrumentation_mongodb_1.MongoDBInstrumentation(this._config.instrumentationOptions.mongoDb));
        }
        if (this._config.instrumentationOptions.mySql?.enabled) {
            this._instrumentations.push(new instrumentation_mysql_1.MySQLInstrumentation(this._config.instrumentationOptions.mySql));
        }
        if (this._config.instrumentationOptions.postgreSql?.enabled) {
            this._instrumentations.push(new instrumentation_pg_1.PgInstrumentation(this._config.instrumentationOptions.postgreSql));
        }
        if (this._config.instrumentationOptions.redis?.enabled) {
            this._instrumentations.push(new instrumentation_redis_1.RedisInstrumentation(this._config.instrumentationOptions.redis));
        }
        if (this._config.instrumentationOptions.redis4?.enabled) {
            this._instrumentations.push(new instrumentation_redis_4_1.RedisInstrumentation(this._config.instrumentationOptions.redis4));
        }
    }
}
exports.TraceHandler = TraceHandler;
//# sourceMappingURL=handler.js.map