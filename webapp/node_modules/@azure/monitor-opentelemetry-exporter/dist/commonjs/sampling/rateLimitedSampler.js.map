{"version":3,"file":"rateLimitedSampler.js","sourceRoot":"","sources":["../../../src/sampling/rateLimitedSampler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { Link, Attributes, SpanKind, Context } from \"@opentelemetry/api\";\nimport type { Sampler, SamplingResult } from \"@opentelemetry/sdk-trace-base\";\nimport { SamplingDecision } from \"@opentelemetry/sdk-trace-base\";\nimport { roundDownToNearest, shouldSample } from \"./samplingUtils.js\";\n\ntype RateLimitedSamplerState = {\n  effectiveWindowCount: number;\n  effectiveWindowNanos: number;\n  lastNanoTime: number;\n};\n\n/**\n * RateLimitedSampler is responsible for the following:\n * - Implements a rate-limiting sampling strategy based on a specified number of requests per second.\n * - Dynamically adjusts the sampling rate based on the time elapsed since the last sample.\n * - Provides a sampling rate that can be used to determine whether a span should be recorded.\n * @param requestsPerSecond -\n */\nexport class RateLimitedSampler implements Sampler {\n  private readonly nanoTimeSupplier: () => number;\n  private readonly inverseAdaptationTimeNanos: number;\n  private readonly targetSpansPerNanosecondLimit: number;\n  private state: RateLimitedSamplerState;\n  private readonly roundToNearest: boolean;\n  private readonly tracesPerSecond: number;\n\n  /**\n   * Initializes a new instance of the RateLimitedSampler class.\n   * @param tracesPerSecond - The maximum number of traces to sample per second.\n   * @throws Error if tracesPerSecond is negative.\n   */\n  constructor(tracesPerSecond: number) {\n    this.tracesPerSecond = tracesPerSecond;\n    if (this.tracesPerSecond < 0.0) {\n      throw new Error(\"Limit for sampled traces per second must be nonnegative\");\n    }\n    const adaptationTimeSeconds = 0.1;\n    this.nanoTimeSupplier = () => Number(process.hrtime.bigint());\n    this.inverseAdaptationTimeNanos = 1e-9 / adaptationTimeSeconds;\n    this.targetSpansPerNanosecondLimit = 1e-9 * this.tracesPerSecond;\n    const now = this.nanoTimeSupplier();\n    this.state = {\n      effectiveWindowCount: 0,\n      effectiveWindowNanos: 0,\n      lastNanoTime: now,\n    };\n    this.roundToNearest = true;\n  }\n\n  /**\n   * Updates the state of the sampler based on the current time.\n   * This method calculates the effective window count and nanos based on the time elapsed since the last sample.\n   * @param oldState - The previous state of the sampler.\n   * @param currentNanoTime - The current time in nanoseconds.\n   * @returns The updated state of the sampler.\n   */\n  private updateState(\n    oldState: RateLimitedSamplerState,\n    currentNanoTime: number,\n  ): RateLimitedSamplerState {\n    if (currentNanoTime <= oldState.lastNanoTime) {\n      return {\n        effectiveWindowCount: oldState.effectiveWindowCount + 1,\n        effectiveWindowNanos: oldState.effectiveWindowNanos,\n        lastNanoTime: oldState.lastNanoTime,\n      };\n    }\n    const nanoTimeDelta = currentNanoTime - oldState.lastNanoTime;\n    const decayFactor = Math.exp(-nanoTimeDelta * this.inverseAdaptationTimeNanos);\n    const currentEffectiveWindowCount = oldState.effectiveWindowCount * decayFactor + 1;\n    const currentEffectiveWindowNanos = oldState.effectiveWindowNanos * decayFactor + nanoTimeDelta;\n    return {\n      effectiveWindowCount: currentEffectiveWindowCount,\n      effectiveWindowNanos: currentEffectiveWindowNanos,\n      lastNanoTime: currentNanoTime,\n    };\n  }\n\n  /**\n   * Gets the current sample rate based on the effective window count and nanos.\n   * This method calculates the sampling probability and returns it as a percentage.\n   * If `roundToNearest` is true, it rounds down the sampling percentage to the nearest whole number.\n   * @returns The current sample rate as a percentage.\n   */\n  public getSampleRate(): number {\n    const currentNanoTime = this.nanoTimeSupplier();\n    this.state = this.updateState(this.state, currentNanoTime);\n\n    const samplingProbability =\n      (this.state.effectiveWindowNanos * this.targetSpansPerNanosecondLimit) /\n      this.state.effectiveWindowCount;\n    let samplingPercentage = 100 * Math.min(samplingProbability, 1);\n\n    if (this.roundToNearest) {\n      samplingPercentage = roundDownToNearest(samplingPercentage);\n    }\n    return samplingPercentage;\n  }\n\n  /**\n   * Checks whether span needs to be created and tracked.\n   *\n   * @param context - Parent Context which may contain a span.\n   * @param traceId - traceId of the span to be created. It can be different from the\n   *     traceId in the {@link SpanContext}. Typically in situations when the\n   *     span to be created starts a new trace.\n   * @param spanName - Name of the span to be created.\n   * @param spanKind - Kind of the span to be created.\n   * @param attributes - Initial set of SpanAttributes for the Span being constructed.\n   * @param links - Collection of links that will be associated with the Span to\n   *     be created. Typically useful for batch operations.\n   * @returns a {@link SamplingResult}.\n   */\n  public shouldSample(\n    context: Context,\n    traceId: string,\n    // @ts-expect-error unused argument\n    spanName: string,\n    // @ts-expect-error unused argument\n    spanKind: SpanKind,\n    attributes: Attributes,\n    // @ts-expect-error unused argument\n    links: Link[],\n  ): SamplingResult {\n    const sampleRate = this.getSampleRate();\n    return shouldSample(sampleRate, context, traceId, attributes)\n      ? { decision: SamplingDecision.RECORD_AND_SAMPLED, attributes: attributes }\n      : { decision: SamplingDecision.NOT_RECORD, attributes: attributes };\n  }\n\n  /**\n   * Return Sampler description\n   */\n  public toString(): string {\n    return `RateLimitedSampler{${this.tracesPerSecond}}`;\n  }\n}\n"]}