{"version":3,"file":"customerSDKStats.js","sourceRoot":"","sources":["../../../../src/export/statsbeat/customerSDKStats.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { BatchObservableResult, Meter, ObservableGauge } from \"@opentelemetry/api\";\nimport { diag } from \"@opentelemetry/api\";\nimport type { PeriodicExportingMetricReaderOptions } from \"@opentelemetry/sdk-metrics\";\nimport { MeterProvider, PeriodicExportingMetricReader } from \"@opentelemetry/sdk-metrics\";\nimport type { AzureMonitorExporterOptions } from \"../../index.js\";\nimport * as ai from \"../../utils/constants/applicationinsights.js\";\nimport { StatsbeatMetrics } from \"./statsbeatMetrics.js\";\nimport type { CustomerSDKStatsProperties, StatsbeatOptions } from \"./types.js\";\nimport {\n  CustomerSDKStats,\n  DropCode,\n  RetryCode,\n  ExceptionType,\n  DropReason,\n  RetryReason,\n} from \"./types.js\";\nimport { CustomSDKStatsCounter, STATSBEAT_LANGUAGE, TelemetryType } from \"./types.js\";\nimport { getAttachType } from \"../../utils/metricUtils.js\";\nimport { AzureMonitorStatsbeatExporter } from \"./statsbeatExporter.js\";\nimport { BreezePerformanceCounterNames } from \"../../types.js\";\nimport type { MetricsData, RemoteDependencyData, RequestData } from \"../../generated/index.js\";\nimport type { TelemetryItem as Envelope } from \"../../generated/index.js\";\n\n/**\n * Class that handles customer-facing SDK Stats metrics\n * These metrics are sent to the customer's breeze endpoint\n *\n * Implements a singleton pattern to ensure only one set of customer SDK Stats metrics\n * is exported every 15 minutes, regardless of the number of exporters or senders.\n */\nexport class CustomerSDKStatsMetrics extends StatsbeatMetrics {\n  private static _instance: CustomerSDKStatsMetrics | undefined;\n\n  private statsCollectionInterval: number = 900000; // 15 minutes\n  private customerSDKStatsMeter: Meter;\n  private customerSDKStatsMeterProvider: MeterProvider;\n  private customerSDKStatsExporter: AzureMonitorStatsbeatExporter;\n  private customerSDKStatsCounter: CustomerSDKStats;\n  private customerSDKStatsMetricReader: PeriodicExportingMetricReader;\n  private isInitialized: boolean = false;\n\n  // Custom dimensions\n  private language: string;\n  private version: string;\n  private attach: string = getAttachType();\n\n  // Observable Gauges\n  private itemSuccessCountGauge: ObservableGauge;\n  private itemDropCountGauge: ObservableGauge;\n  private itemRetryCountGauge: ObservableGauge;\n\n  // Customer SDK Stats properties\n  private customerProperties: CustomerSDKStatsProperties;\n\n  private constructor(options: StatsbeatOptions) {\n    super();\n    const exporterConfig: AzureMonitorExporterOptions = {\n      connectionString: `InstrumentationKey=${options.instrumentationKey};IngestionEndpoint=${options.endpointUrl}`,\n    };\n\n    this.customerSDKStatsExporter = new AzureMonitorStatsbeatExporter(exporterConfig);\n    // Exports Customer SDK Stats every 15 minutes\n    const customerMetricReaderOptions: PeriodicExportingMetricReaderOptions = {\n      exporter: this.customerSDKStatsExporter,\n      exportIntervalMillis: options.networkCollectionInterval || this.statsCollectionInterval,\n    };\n    this.customerSDKStatsMetricReader = new PeriodicExportingMetricReader(\n      customerMetricReaderOptions,\n    );\n    this.customerSDKStatsMeterProvider = new MeterProvider({\n      readers: [this.customerSDKStatsMetricReader],\n    });\n\n    this.customerSDKStatsMeter = this.customerSDKStatsMeterProvider.getMeter(\n      \"Azure Monitor Customer SDK Stats\",\n    );\n\n    this.language = STATSBEAT_LANGUAGE;\n    this.version = ai.packageVersion;\n\n    this.itemSuccessCountGauge = this.customerSDKStatsMeter.createObservableGauge(\n      CustomSDKStatsCounter.ITEM_SUCCESS_COUNT,\n    );\n    this.itemDropCountGauge = this.customerSDKStatsMeter.createObservableGauge(\n      CustomSDKStatsCounter.ITEM_DROP_COUNT,\n    );\n    this.itemRetryCountGauge = this.customerSDKStatsMeter.createObservableGauge(\n      CustomSDKStatsCounter.ITEM_RETRY_COUNT,\n    );\n\n    if (!this.isInitialized) {\n      this.initialize();\n    }\n    this.isInitialized = true;\n\n    // Initialize the single customer SDK Stats counter\n    this.customerSDKStatsCounter = new CustomerSDKStats();\n\n    this.customerProperties = {\n      language: this.language,\n      version: this.version,\n      computeType: this.attach,\n    };\n  }\n\n  /**\n   * Get singleton instance of CustomerSDKStatsMetrics\n   * @param options - Configuration options for customer SDK Stats metrics\n   * @returns The singleton instance\n   */\n  public static getInstance(options: StatsbeatOptions): CustomerSDKStatsMetrics {\n    if (!CustomerSDKStatsMetrics._instance) {\n      CustomerSDKStatsMetrics._instance = new CustomerSDKStatsMetrics(options);\n    }\n    return CustomerSDKStatsMetrics._instance;\n  }\n\n  /**\n   * Shutdown the singleton instance\n   * Used for cleanup and complete shutdown\n   */\n  public static shutdown(): Promise<void> | undefined {\n    if (CustomerSDKStatsMetrics._instance) {\n      const shutdownPromise = CustomerSDKStatsMetrics._instance.shutdown();\n      CustomerSDKStatsMetrics._instance = undefined;\n      return shutdownPromise;\n    }\n    return undefined;\n  }\n\n  /**\n   * Shuts down the customer SDK Stats metrics provider\n   * @returns Promise<void>\n   */\n  public shutdown(): Promise<void> {\n    return this.customerSDKStatsMeterProvider.shutdown();\n  }\n\n  /**\n   * Initializes the customer SDK Stats metrics\n   * Sets up the resource provider and adds observable callbacks for each metric\n   * @returns Promise<void>\n   */\n  private async initialize(): Promise<void> {\n    try {\n      await super.getResourceProvider();\n      this.customerSDKStatsMeter.addBatchObservableCallback(this.itemSuccessCallback.bind(this), [\n        this.itemSuccessCountGauge,\n      ]);\n      this.customerSDKStatsMeter.addBatchObservableCallback(this.itemDropCallback.bind(this), [\n        this.itemDropCountGauge,\n      ]);\n      this.customerSDKStatsMeter.addBatchObservableCallback(this.itemRetryCallback.bind(this), [\n        this.itemRetryCountGauge,\n      ]);\n    } catch (error) {\n      diag.debug(\"Call to get the resource provider failed for customer SDK Stats metrics.\");\n    }\n  }\n\n  // Observable gauge callbacks\n  private itemSuccessCallback(observableResult: BatchObservableResult): void {\n    const counter: CustomerSDKStats = this.customerSDKStatsCounter;\n    const attributes = { ...this.customerProperties, telemetry_type: TelemetryType.UNKNOWN };\n\n    // For each { telemetry_type -> count } mapping, call observe, passing the count and attributes that include the telemetry_type\n    for (const [telemetry_type, count] of counter.totalItemSuccessCount.entries()) {\n      // Only send metrics if count is greater than zero\n      if (count > 0) {\n        attributes.telemetry_type = telemetry_type;\n        observableResult.observe(this.itemSuccessCountGauge, count, {\n          ...attributes,\n        });\n        counter.totalItemSuccessCount.set(telemetry_type, 0);\n      }\n    }\n  }\n\n  private itemDropCallback(observableResult: BatchObservableResult): void {\n    const counter: CustomerSDKStats = this.customerSDKStatsCounter;\n    const baseAttributes: CustomerSDKStatsProperties & {\n      \"drop.code\": DropCode | number;\n      telemetry_type: TelemetryType;\n    } = {\n      ...this.customerProperties,\n      \"drop.code\": DropCode.UNKNOWN,\n      telemetry_type: TelemetryType.UNKNOWN,\n    };\n\n    // Iterate through the nested Map structure: telemetry_type -> drop.code -> reason -> telemetry_success -> count\n    for (const [telemetryType, dropCodeMap] of counter.totalItemDropCount.entries()) {\n      for (const [dropCode, reasonMap] of dropCodeMap.entries()) {\n        for (const [reason, successMap] of reasonMap.entries()) {\n          for (const [success, count] of successMap.entries()) {\n            const attributes = { ...baseAttributes };\n            attributes.telemetry_type = telemetryType;\n            attributes[\"drop.code\"] = dropCode;\n\n            // Include drop.reason for all cases\n            if (reason) {\n              (attributes as any)[\"drop.reason\"] = reason;\n            }\n\n            // Include telemetry_success only for request/dependency telemetry when success is not null\n            if (\n              (telemetryType === TelemetryType.REQUEST ||\n                telemetryType === TelemetryType.DEPENDENCY) &&\n              success !== null\n            ) {\n              (attributes as any)[\"telemetry_success\"] = success;\n            }\n\n            // Only send metrics if count is greater than zero\n            if (count > 0) {\n              observableResult.observe(this.itemDropCountGauge, count, {\n                ...attributes,\n              });\n            }\n\n            // Reset the count to 0\n            successMap.set(success, 0);\n          }\n        }\n      }\n    }\n  }\n\n  private itemRetryCallback(observableResult: BatchObservableResult): void {\n    const counter: CustomerSDKStats = this.customerSDKStatsCounter;\n    const baseAttributes: CustomerSDKStatsProperties & {\n      \"retry.code\": RetryCode | number;\n      telemetry_type: TelemetryType;\n    } = {\n      ...this.customerProperties,\n      \"retry.code\": RetryCode.UNKNOWN,\n      telemetry_type: TelemetryType.UNKNOWN,\n    };\n\n    // Iterate through the nested Map structure: telemetry_type -> retry.code -> reason -> count\n    for (const [telemetryType, retryCodeMap] of counter.totalItemRetryCount.entries()) {\n      for (const [retryCode, reasonMap] of retryCodeMap.entries()) {\n        for (const [reason, count] of reasonMap.entries()) {\n          const attributes = { ...baseAttributes };\n          attributes.telemetry_type = telemetryType;\n          attributes[\"retry.code\"] = retryCode;\n\n          // Include retry.reason for all cases\n          if (reason) {\n            (attributes as any)[\"retry.reason\"] = reason;\n          }\n\n          // Only send metrics if count is greater than zero\n          if (count > 0) {\n            observableResult.observe(this.itemRetryCountGauge, count, {\n              ...attributes,\n            });\n          }\n\n          // Reset the count to 0\n          reasonMap.set(reason, 0);\n        }\n      }\n    }\n  }\n\n  // Public methods to track metrics\n  /**\n   * Tracks succcessful items\n   * @param envelopes - Number of successful envelopes\n   * @param telemetry_type - The type of telemetry being tracked\n   */\n  public countSuccessfulItems(envelopes: Envelope[]): void {\n    const counter: CustomerSDKStats = this.customerSDKStatsCounter;\n    let telemetry_type: TelemetryType;\n\n    // Get the current count for this telemetry type, or 0 if it doesn't exist\n    for (const envelope of envelopes) {\n      telemetry_type = this.getTelemetryTypeFromEnvelope(envelope);\n      const currentCount = counter.totalItemSuccessCount.get(telemetry_type) || 0;\n      counter.totalItemSuccessCount.set(telemetry_type, currentCount + 1);\n    }\n  }\n\n  /**\n   * Tracks dropped items\n   * @param envelopes - Array of envelopes dropped\n   * @param dropCode - The drop code indicating the reason for drop\n   * @param exceptionMessage - Optional exception message when dropCode is CLIENT_EXCEPTION\n   * @param exceptionType - Optional explicit exception type override when dropCode is CLIENT_EXCEPTION\n   */\n  public countDroppedItems(\n    envelopes: Envelope[],\n    dropCode: DropCode | number,\n    exceptionMessage?: string,\n    exceptionType?: ExceptionType,\n  ): void {\n    const counter: CustomerSDKStats = this.customerSDKStatsCounter;\n    let telemetry_type: TelemetryType;\n\n    for (const envelope of envelopes) {\n      telemetry_type = this.getTelemetryTypeFromEnvelope(envelope);\n\n      let dropCodeMap = counter.totalItemDropCount.get(telemetry_type);\n      if (!dropCodeMap) {\n        dropCodeMap = new Map<DropCode | number, Map<string, Map<boolean | null, number>>>();\n        counter.totalItemDropCount.set(telemetry_type, dropCodeMap);\n      }\n\n      // Get or create the reason map for this dropCode\n      let reasonMap = dropCodeMap.get(dropCode);\n      if (!reasonMap) {\n        reasonMap = new Map<string, Map<boolean | null, number>>();\n        dropCodeMap.set(dropCode, reasonMap);\n      }\n\n      // Generate a low-cardinality, informative reason description\n      const reason = this.getDropReason(dropCode, exceptionMessage, exceptionType);\n\n      // Get or create the success map for this reason\n      let successMap = reasonMap.get(reason);\n      if (!successMap) {\n        successMap = new Map<boolean | null, number>();\n        reasonMap.set(reason, successMap);\n      }\n\n      // For non-request/dependency telemetry or when success is not provided, use null as the success key\n      const individualTelemetrySuccess = this.getTelemetrySuccessFromEnvelope(envelope);\n      const successKey =\n        (telemetry_type === TelemetryType.REQUEST || telemetry_type === TelemetryType.DEPENDENCY) &&\n        individualTelemetrySuccess !== undefined\n          ? individualTelemetrySuccess\n          : null;\n\n      // Update the count for this reason and success combination\n      const currentCount = successMap.get(successKey) || 0;\n      successMap.set(successKey, currentCount + 1);\n    }\n  }\n\n  /**\n   * Generates a low-cardinality, informative description for drop reasons\n   * @param dropCode - The drop code (enum value or status code number)\n   * @param exceptionMessage - Optional exception message for CLIENT_EXCEPTION\n   * @param exceptionType - Optional explicit exception type override for CLIENT_EXCEPTION\n   * @returns A descriptive reason string with low cardinality\n   */\n  private getDropReason(\n    dropCode: DropCode | number,\n    exceptionMessage?: string,\n    exceptionType?: ExceptionType,\n  ): string {\n    if (dropCode === DropCode.CLIENT_EXCEPTION) {\n      // If an explicit exception type is provided, use it\n      if (exceptionType) {\n        return exceptionType;\n      }\n      // For client exceptions, derive a well-known exception category from the exception message\n      if (exceptionMessage) {\n        return this.categorizeExceptionMessage(exceptionMessage);\n      }\n      return ExceptionType.CLIENT_EXCEPTION; // Default to \"Client exception\" if no message provided\n    }\n\n    // Handle status code drop codes (numeric values)\n    if (typeof dropCode === \"number\") {\n      return this.categorizeStatusCode(dropCode);\n    }\n\n    // Handle other enum drop codes\n    switch (dropCode) {\n      case DropCode.CLIENT_READONLY:\n        return DropReason.CLIENT_READONLY;\n      case DropCode.CLIENT_PERSISTENCE_CAPACITY:\n        return DropReason.CLIENT_PERSISTENCE_CAPACITY;\n      case DropCode.CLIENT_STORAGE_DISABLED:\n        return DropReason.CLIENT_STORAGE_DISABLED;\n      case DropCode.UNKNOWN:\n      default:\n        return DropReason.UNKNOWN;\n    }\n  }\n\n  /**\n   * Categorizes exception messages into well-known exception categories\n   * @param exceptionMessage - The exception message to categorize\n   * @returns A well-known exception category string\n   */\n  private categorizeExceptionMessage(exceptionMessage: string): ExceptionType {\n    const message = exceptionMessage.toLowerCase();\n\n    if (message.includes(\"timeout\") || message.includes(\"timed out\")) {\n      return ExceptionType.TIMEOUT_EXCEPTION;\n    }\n    if (\n      message.includes(\"network\") ||\n      message.includes(\"connection\") ||\n      message.includes(\"dns\") ||\n      message.includes(\"socket\")\n    ) {\n      return ExceptionType.NETWORK_EXCEPTION;\n    }\n    if (\n      message.includes(\"disk\") ||\n      message.includes(\"storage\") ||\n      message.includes(\"file\") ||\n      message.includes(\"persist\")\n    ) {\n      return ExceptionType.STORAGE_EXCEPTION;\n    }\n\n    // Default to Client exception for any other cases\n    return ExceptionType.CLIENT_EXCEPTION;\n  }\n\n  /**\n   * Categorizes HTTP status codes into informative descriptions\n   * @param statusCode - The HTTP status code\n   * @returns A descriptive category string\n   */\n  private categorizeStatusCode(statusCode: number): string {\n    if (statusCode >= 400 && statusCode < 500) {\n      switch (statusCode) {\n        case 400:\n          return \"Bad request\";\n        case 401:\n          return \"Unauthorized\";\n        case 403:\n          return \"Forbidden\";\n        case 404:\n          return \"Not found\";\n        case 408:\n          return \"Request timeout\";\n        case 413:\n          return \"Payload too large\";\n        case 429:\n          return \"Too many requests\";\n        default:\n          return \"Client error 4xx\";\n      }\n    }\n\n    if (statusCode >= 500 && statusCode < 600) {\n      switch (statusCode) {\n        case 500:\n          return \"Internal server error\";\n        case 502:\n          return \"Bad gateway\";\n        case 503:\n          return \"Service unavailable\";\n        case 504:\n          return \"Gateway timeout\";\n        default:\n          return \"Server error 5xx\";\n      }\n    }\n\n    return `status_${statusCode}`;\n  }\n  /**\n   * Tracks retried envelopes\n   * @param envelopes - Number of envelopes retried\n   * @param retryCode - The retry code indicating the reason for retry\n   * @param exceptionMessage - Optional exception message when retryCode is CLIENT_EXCEPTION\n   * @param exceptionType - Optional explicit exception type override when retryCode is CLIENT_EXCEPTION\n   */\n  public countRetryItems(\n    envelopes: Envelope[],\n    retryCode: RetryCode | number,\n    exceptionMessage?: string,\n    exceptionType?: ExceptionType,\n  ): void {\n    const counter: CustomerSDKStats = this.customerSDKStatsCounter;\n    let telemetry_type: TelemetryType;\n\n    for (const envelope of envelopes) {\n      telemetry_type = this.getTelemetryTypeFromEnvelope(envelope);\n      // Get or create the retryCode map for this telemetry_type\n      let retryCodeMap = counter.totalItemRetryCount.get(telemetry_type);\n      if (!retryCodeMap) {\n        retryCodeMap = new Map<RetryCode | number, Map<string, number>>();\n        counter.totalItemRetryCount.set(telemetry_type, retryCodeMap);\n      }\n\n      // Get or create the reason map for this retryCode\n      let reasonMap = retryCodeMap.get(retryCode);\n      if (!reasonMap) {\n        reasonMap = new Map<string, number>();\n        retryCodeMap.set(retryCode, reasonMap);\n      }\n\n      // Generate a low-cardinality, informative reason description\n      const reason = this.getRetryReason(retryCode, exceptionMessage, exceptionType);\n\n      // Update the count for this reason\n      const currentCount = reasonMap.get(reason) || 0;\n      reasonMap.set(reason, currentCount + 1);\n    }\n  }\n\n  /**\n   * Generates a low-cardinality, informative description for retry reasons\n   * @param retryCode - The retry code (enum value or status code number)\n   * @param exceptionMessage - Optional exception message for CLIENT_EXCEPTION\n   * @param exceptionType - Optional explicit exception type override for CLIENT_EXCEPTION\n   * @returns A descriptive reason string with low cardinality\n   */\n  private getRetryReason(\n    retryCode: RetryCode | number,\n    exceptionMessage?: string,\n    exceptionType?: ExceptionType,\n  ): string {\n    if (retryCode === RetryCode.CLIENT_EXCEPTION) {\n      // If an explicit exception type is provided, use it\n      if (exceptionType) {\n        return exceptionType;\n      }\n      // For client exceptions, derive a low-cardinality reason from the exception message\n      if (exceptionMessage) {\n        return this.categorizeExceptionMessage(exceptionMessage);\n      }\n      return ExceptionType.CLIENT_EXCEPTION;\n    }\n\n    // Handle status code retry codes (numeric values)\n    if (typeof retryCode === \"number\") {\n      return this.categorizeStatusCode(retryCode);\n    }\n\n    // Handle other enum retry codes\n    switch (retryCode) {\n      case RetryCode.CLIENT_TIMEOUT:\n        return RetryReason.CLIENT_TIMEOUT;\n      case RetryCode.UNKNOWN:\n      default:\n        return RetryReason.UNKNOWN;\n    }\n  }\n\n  /**\n   * Check if a metric name corresponds to a performance counter\n   * @param metricName - The name of the metric to check\n   * @returns true if the metric name is a performance counter, false otherwise\n   */\n  private isPerformanceCounterMetric(metricName: string): boolean {\n    return Object.values(BreezePerformanceCounterNames).includes(\n      metricName as BreezePerformanceCounterNames,\n    );\n  }\n\n  /**\n   * Extract telemetry type from an envelope based on its baseType\n   * @param envelope - The envelope to extract telemetry type from\n   * @returns The corresponding telemetry type\n   */\n  public getTelemetryTypeFromEnvelope(envelope: Envelope): TelemetryType {\n    if (envelope.data && envelope.data.baseType) {\n      switch (envelope.data.baseType) {\n        case \"MessageData\":\n          return TelemetryType.TRACE;\n        case \"AvailabilityData\":\n          return TelemetryType.AVAILABILITY;\n        case \"TelemetryEventData\":\n          return TelemetryType.CUSTOM_EVENT;\n        case \"TelemetryExceptionData\":\n          return TelemetryType.EXCEPTION;\n        case \"PageViewData\":\n          return TelemetryType.PAGE_VIEW;\n        case \"RemoteDependencyData\":\n          return TelemetryType.DEPENDENCY;\n        case \"RequestData\":\n          return TelemetryType.REQUEST;\n        case \"MetricData\": {\n          const metricsData = envelope.data.baseData as MetricsData;\n          if (metricsData && metricsData.metrics && metricsData.metrics.length > 0) {\n            // Check if any of the metrics are performance counters\n            const hasPerformanceCounter = metricsData.metrics.some((metric) =>\n              this.isPerformanceCounterMetric(metric.name),\n            );\n            return hasPerformanceCounter\n              ? TelemetryType.PERFORMANCE_COUNTER\n              : TelemetryType.CUSTOM_METRIC;\n          }\n          return TelemetryType.CUSTOM_METRIC;\n        }\n        default:\n          return TelemetryType.UNKNOWN;\n      }\n    }\n    return TelemetryType.UNKNOWN;\n  }\n\n  /**\n   * Extract telemetry success value from an envelope for REQUEST and DEPENDENCY telemetry types\n   * @param envelope - The envelope to extract success value from\n   * @returns The success value if available, undefined otherwise\n   */\n  public getTelemetrySuccessFromEnvelope(envelope: Envelope): boolean | undefined {\n    if (!envelope.data || !envelope.data.baseData) {\n      return undefined;\n    }\n\n    const baseType = envelope.data.baseType;\n    if (baseType === \"RequestData\") {\n      const requestData = envelope.data.baseData as RequestData;\n      return requestData.success;\n    } else if (baseType === \"RemoteDependencyData\") {\n      const dependencyData = envelope.data.baseData as RemoteDependencyData;\n      return dependencyData.success;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Checks if the given error is a timeout-related error\n   * @param error - The error to check\n   * @returns true if the error is timeout-related, false otherwise\n   */\n  public isTimeoutError(error: { code?: string; message?: string }): boolean {\n    // Check for various timeout error codes that indicate client timeouts\n    const timeoutErrorCodes = [\n      \"ETIMEDOUT\", // Connection timed out\n      \"ESOCKETTIMEDOUT\", // Socket timeout\n      \"ECONNRESET\", // Connection reset (often due to timeout)\n      \"ENOTFOUND\", // DNS lookup failed/timeout\n    ];\n\n    if (error && error.code && timeoutErrorCodes.includes(error.code)) {\n      return true;\n    }\n\n    // Also check if the error message contains timeout-related keywords\n    if (error && error.message) {\n      const timeoutKeywords = [\"timeout\", \"timed out\", \"connection reset\"];\n      const errorMessage = error.message.toLowerCase();\n      return timeoutKeywords.some((keyword) => errorMessage.includes(keyword));\n    }\n\n    return false;\n  }\n}\n"]}