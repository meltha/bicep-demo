{"version":3,"file":"samplingUtils.js","sourceRoot":"","sources":["../../../src/sampling/samplingUtils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { Attributes, Context } from \"@opentelemetry/api\";\nimport { trace, TraceFlags } from \"@opentelemetry/api\";\nimport { AzureMonitorSampleRate } from \"../utils/constants/applicationinsights.js\";\n\n/**\n * Computes a deterministic hash code from a string input (typically a trace ID)\n * and returns a value between 0 and 100 for sampling decisions.\n *\n * This function replicates the C# hash algorithm used in Application Insights\n * to ensure consistent sampling decisions across different SDKs and languages.\n * The same trace ID will always produce the same hash value, enabling\n * distributed sampling where all spans in a trace are sampled consistently.\n *\n * @param input - The input string to hash (usually a trace ID)\n * @returns A number between 0 and 100 representing the hash-based sampling score\n */\nexport function getSamplingHashCode(input: string): number {\n  const csharpMin = -2147483648;\n  const csharpMax = 2147483647;\n  let hash = 5381;\n\n  if (!input) {\n    return 0;\n  }\n\n  // Ensure input is at least 8 characters long by repeating it\n  let processedInput = input;\n  while (processedInput.length < 8) {\n    processedInput = processedInput + processedInput;\n  }\n\n  // Compute hash using a variation of djb2 algorithm with C# integer overflow simulation\n  // This uses hash * 33 + c (where hash << 5 + hash equals hash * 33)\n  for (let i = 0; i < processedInput.length; i++) {\n    // JS doesn't respond to integer overflow by wrapping around. Simulate it with bitwise operators ( | 0)\n    hash = ((((hash << 5) + hash) | 0) + processedInput.charCodeAt(i)) | 0;\n  }\n\n  // Normalize hash to positive value and convert to 0-100 range\n  hash = hash <= csharpMin ? csharpMax : Math.abs(hash);\n  return (hash / csharpMax) * 100;\n}\n\nexport function roundDownToNearest(samplingPercentage: number): number {\n  if (samplingPercentage === 0) {\n    return 0;\n  }\n  const itemCount = 100 / samplingPercentage;\n  return 100.0 / Math.ceil(itemCount);\n}\n\nexport function shouldSample(\n  samplePercentage: number,\n  context: Context,\n  traceId: string,\n  attributes: Attributes,\n): boolean {\n  let sampleRate = samplePercentage;\n  let isSampled = undefined;\n\n  if (sampleRate === 100) {\n    isSampled = true;\n  } else if (sampleRate === 0) {\n    isSampled = false;\n  } else {\n    // Try to get the parent sampling result first\n    const parentSpan = trace.getSpan(context);\n    const parentSpanContext = parentSpan?.spanContext();\n    if (\n      parentSpanContext &&\n      trace.isSpanContextValid(parentSpanContext) &&\n      !parentSpanContext.isRemote\n    ) {\n      if ((parentSpanContext.traceFlags & TraceFlags.SAMPLED) === TraceFlags.SAMPLED) {\n        isSampled = true;\n      } else if ((parentSpanContext.traceFlags & TraceFlags.NONE) === TraceFlags.NONE) {\n        isSampled = false;\n      }\n      // If the parent span is valid and not remote, we can use its sample rate\n      const parentSampleRate = Number((parentSpan as any).attributes?.[AzureMonitorSampleRate]);\n      if (!isNaN(parentSampleRate)) {\n        sampleRate = Number(parentSampleRate);\n      }\n    }\n  }\n\n  // Only add sample rate attribute if it's not 100\n  if (sampleRate !== 100) {\n    // Add sample rate as span attribute\n    attributes = attributes || {};\n    attributes[AzureMonitorSampleRate] = sampleRate;\n  }\n\n  if (isSampled === undefined) {\n    const samplingHashCode = getSamplingHashCode(traceId);\n    return samplingHashCode < sampleRate;\n  } else {\n    return isSampled;\n  }\n}\n"]}