"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.flushAzureMonitor = exports.shutdownAzureMonitor = exports.useAzureMonitor = void 0;
const monitor_opentelemetry_1 = require("@azure/monitor-opentelemetry");
const api_1 = require("@opentelemetry/api");
const api_logs_1 = require("@opentelemetry/api-logs");
const sdk_logs_1 = require("@opentelemetry/sdk-logs");
const sdk_trace_node_1 = require("@opentelemetry/sdk-trace-node");
const exporter_logs_otlp_http_1 = require("@opentelemetry/exporter-logs-otlp-http");
const exporter_trace_otlp_http_1 = require("@opentelemetry/exporter-trace-otlp-http");
const autoCollectLogs_1 = require("./logs/autoCollectLogs");
const exceptions_1 = require("./logs/exceptions");
const config_1 = require("./shared/configuration/config");
const logsApi_1 = require("./shim/logsApi");
const types_1 = require("./shim/types");
const statsbeatFeaturesManager_1 = require("./shared/util/statsbeatFeaturesManager");
let autoCollectLogs;
let exceptions;
/**
 * Initialize Azure Monitor
 * @param options Configuration
 */
function useAzureMonitor(options) {
    // Initialize statsbeat features with default values and enable SHIM feature
    statsbeatFeaturesManager_1.StatsbeatFeaturesManager.getInstance().initialize();
    statsbeatFeaturesManager_1.StatsbeatFeaturesManager.getInstance().enableFeature(types_1.StatsbeatFeature.SHIM);
    // Allows for full filtering of dependency/request spans
    const internalConfig = new config_1.ApplicationInsightsConfig(options);
    // Add OTLP exporters if configured
    const otlpSpanProcessor = _getOtlpSpanExporter(internalConfig);
    const otlpLogProcessor = _getOtlpLogExporter(internalConfig);
    // Ensure options object exists and add processors
    if (!options) {
        options = {};
    }
    if (otlpSpanProcessor) {
        if (!options.spanProcessors) {
            options.spanProcessors = [];
        }
        options.spanProcessors.push(otlpSpanProcessor);
    }
    if (otlpLogProcessor) {
        if (!options.logRecordProcessors) {
            options.logRecordProcessors = [];
        }
        options.logRecordProcessors.push(otlpLogProcessor);
    }
    (0, monitor_opentelemetry_1.useAzureMonitor)(options);
    const logApi = new logsApi_1.LogApi(api_logs_1.logs.getLogger("ApplicationInsightsLogger"));
    autoCollectLogs = new autoCollectLogs_1.AutoCollectLogs();
    if (internalConfig.enableAutoCollectExceptions) {
        exceptions = new exceptions_1.AutoCollectExceptions(logApi);
    }
    autoCollectLogs.enable(internalConfig.instrumentationOptions);
}
exports.useAzureMonitor = useAzureMonitor;
/**
* Shutdown Azure Monitor
*/
async function shutdownAzureMonitor() {
    await (0, monitor_opentelemetry_1.shutdownAzureMonitor)();
    autoCollectLogs.shutdown();
    exceptions === null || exceptions === void 0 ? void 0 : exceptions.shutdown();
}
exports.shutdownAzureMonitor = shutdownAzureMonitor;
/**
 * Try to send all queued telemetry if present.
 */
async function flushAzureMonitor() {
    try {
        await api_1.metrics.getMeterProvider().forceFlush();
        await (api_1.trace.getTracerProvider().getDelegate()).forceFlush();
        await api_logs_1.logs.getLoggerProvider().forceFlush();
    }
    catch (err) {
        api_1.diag.error("Failed to flush telemetry", err);
    }
}
exports.flushAzureMonitor = flushAzureMonitor;
function _getOtlpSpanExporter(internalConfig) {
    var _a;
    if ((_a = internalConfig.otlpTraceExporterConfig) === null || _a === void 0 ? void 0 : _a.enabled) {
        const otlpTraceExporter = new exporter_trace_otlp_http_1.OTLPTraceExporter(internalConfig.otlpTraceExporterConfig);
        const otlpSpanProcessor = new sdk_trace_node_1.BatchSpanProcessor(otlpTraceExporter);
        return otlpSpanProcessor;
    }
}
function _getOtlpLogExporter(internalConfig) {
    var _a;
    if ((_a = internalConfig.otlpLogExporterConfig) === null || _a === void 0 ? void 0 : _a.enabled) {
        const otlpLogExporter = new exporter_logs_otlp_http_1.OTLPLogExporter(internalConfig.otlpLogExporterConfig);
        const otlpLogProcessor = new sdk_logs_1.BatchLogRecordProcessor(otlpLogExporter);
        return otlpLogProcessor;
    }
}
//# sourceMappingURL=main.js.map